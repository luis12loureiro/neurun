// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: task.proto

package gen

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TaskType int32

const (
	TaskType_TASK_TYPE_UNSPECIFIED TaskType = 0
	TaskType_TASK_TYPE_LOG         TaskType = 1
	TaskType_TASK_TYPE_HTTP        TaskType = 2
)

// Enum value maps for TaskType.
var (
	TaskType_name = map[int32]string{
		0: "TASK_TYPE_UNSPECIFIED",
		1: "TASK_TYPE_LOG",
		2: "TASK_TYPE_HTTP",
	}
	TaskType_value = map[string]int32{
		"TASK_TYPE_UNSPECIFIED": 0,
		"TASK_TYPE_LOG":         1,
		"TASK_TYPE_HTTP":        2,
	}
)

func (x TaskType) Enum() *TaskType {
	p := new(TaskType)
	*p = x
	return p
}

func (x TaskType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TaskType) Descriptor() protoreflect.EnumDescriptor {
	return file_task_proto_enumTypes[0].Descriptor()
}

func (TaskType) Type() protoreflect.EnumType {
	return &file_task_proto_enumTypes[0]
}

func (x TaskType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TaskType.Descriptor instead.
func (TaskType) EnumDescriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{0}
}

type TaskStatus int32

const (
	TaskStatus_TASK_STATUS_UNSPECIFIED TaskStatus = 0
	TaskStatus_TASK_STATUS_PENDING     TaskStatus = 1
	TaskStatus_TASK_STATUS_RUNNING     TaskStatus = 2
	TaskStatus_TASK_STATUS_COMPLETED   TaskStatus = 3
	TaskStatus_TASK_STATUS_FAILED      TaskStatus = 4
)

// Enum value maps for TaskStatus.
var (
	TaskStatus_name = map[int32]string{
		0: "TASK_STATUS_UNSPECIFIED",
		1: "TASK_STATUS_PENDING",
		2: "TASK_STATUS_RUNNING",
		3: "TASK_STATUS_COMPLETED",
		4: "TASK_STATUS_FAILED",
	}
	TaskStatus_value = map[string]int32{
		"TASK_STATUS_UNSPECIFIED": 0,
		"TASK_STATUS_PENDING":     1,
		"TASK_STATUS_RUNNING":     2,
		"TASK_STATUS_COMPLETED":   3,
		"TASK_STATUS_FAILED":      4,
	}
)

func (x TaskStatus) Enum() *TaskStatus {
	p := new(TaskStatus)
	*p = x
	return p
}

func (x TaskStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TaskStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_task_proto_enumTypes[1].Descriptor()
}

func (TaskStatus) Type() protoreflect.EnumType {
	return &file_task_proto_enumTypes[1]
}

func (x TaskStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TaskStatus.Descriptor instead.
func (TaskStatus) EnumDescriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{1}
}

type HTTPApiKeyLocation int32

const (
	HTTPApiKeyLocation_HTTP_API_KEY_LOCATION_UNSPECIFIED HTTPApiKeyLocation = 0
	HTTPApiKeyLocation_HTTP_API_KEY_LOCATION_HEADER      HTTPApiKeyLocation = 1
	HTTPApiKeyLocation_HTTP_API_KEY_LOCATION_QUERY       HTTPApiKeyLocation = 2
)

// Enum value maps for HTTPApiKeyLocation.
var (
	HTTPApiKeyLocation_name = map[int32]string{
		0: "HTTP_API_KEY_LOCATION_UNSPECIFIED",
		1: "HTTP_API_KEY_LOCATION_HEADER",
		2: "HTTP_API_KEY_LOCATION_QUERY",
	}
	HTTPApiKeyLocation_value = map[string]int32{
		"HTTP_API_KEY_LOCATION_UNSPECIFIED": 0,
		"HTTP_API_KEY_LOCATION_HEADER":      1,
		"HTTP_API_KEY_LOCATION_QUERY":       2,
	}
)

func (x HTTPApiKeyLocation) Enum() *HTTPApiKeyLocation {
	p := new(HTTPApiKeyLocation)
	*p = x
	return p
}

func (x HTTPApiKeyLocation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HTTPApiKeyLocation) Descriptor() protoreflect.EnumDescriptor {
	return file_task_proto_enumTypes[2].Descriptor()
}

func (HTTPApiKeyLocation) Type() protoreflect.EnumType {
	return &file_task_proto_enumTypes[2]
}

func (x HTTPApiKeyLocation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HTTPApiKeyLocation.Descriptor instead.
func (HTTPApiKeyLocation) EnumDescriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{2}
}

type CreateTaskRequest struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Name       string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type       TaskType               `protobuf:"varint,2,opt,name=type,proto3,enum=neurun.TaskType" json:"type,omitempty"`
	Retries    uint32                 `protobuf:"varint,3,opt,name=retries,proto3" json:"retries,omitempty"`
	RetryDelay *durationpb.Duration   `protobuf:"bytes,4,opt,name=retryDelay,proto3" json:"retryDelay,omitempty"`
	Condition  *string                `protobuf:"bytes,5,opt,name=condition,proto3,oneof" json:"condition,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*CreateTaskRequest_LogPayload
	//	*CreateTaskRequest_HttpPayload
	Payload       isCreateTaskRequest_Payload `protobuf_oneof:"payload"`
	Next          []*CreateTaskRequest        `protobuf:"bytes,8,rep,name=next,proto3" json:"next,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateTaskRequest) Reset() {
	*x = CreateTaskRequest{}
	mi := &file_task_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateTaskRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateTaskRequest) ProtoMessage() {}

func (x *CreateTaskRequest) ProtoReflect() protoreflect.Message {
	mi := &file_task_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateTaskRequest.ProtoReflect.Descriptor instead.
func (*CreateTaskRequest) Descriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{0}
}

func (x *CreateTaskRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateTaskRequest) GetType() TaskType {
	if x != nil {
		return x.Type
	}
	return TaskType_TASK_TYPE_UNSPECIFIED
}

func (x *CreateTaskRequest) GetRetries() uint32 {
	if x != nil {
		return x.Retries
	}
	return 0
}

func (x *CreateTaskRequest) GetRetryDelay() *durationpb.Duration {
	if x != nil {
		return x.RetryDelay
	}
	return nil
}

func (x *CreateTaskRequest) GetCondition() string {
	if x != nil && x.Condition != nil {
		return *x.Condition
	}
	return ""
}

func (x *CreateTaskRequest) GetPayload() isCreateTaskRequest_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *CreateTaskRequest) GetLogPayload() *LogPayload {
	if x != nil {
		if x, ok := x.Payload.(*CreateTaskRequest_LogPayload); ok {
			return x.LogPayload
		}
	}
	return nil
}

func (x *CreateTaskRequest) GetHttpPayload() *HTTPPayload {
	if x != nil {
		if x, ok := x.Payload.(*CreateTaskRequest_HttpPayload); ok {
			return x.HttpPayload
		}
	}
	return nil
}

func (x *CreateTaskRequest) GetNext() []*CreateTaskRequest {
	if x != nil {
		return x.Next
	}
	return nil
}

type isCreateTaskRequest_Payload interface {
	isCreateTaskRequest_Payload()
}

type CreateTaskRequest_LogPayload struct {
	LogPayload *LogPayload `protobuf:"bytes,6,opt,name=logPayload,proto3,oneof"`
}

type CreateTaskRequest_HttpPayload struct {
	HttpPayload *HTTPPayload `protobuf:"bytes,7,opt,name=httpPayload,proto3,oneof"`
}

func (*CreateTaskRequest_LogPayload) isCreateTaskRequest_Payload() {}

func (*CreateTaskRequest_HttpPayload) isCreateTaskRequest_Payload() {}

type Task struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Id         *string                `protobuf:"bytes,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
	Name       string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type       TaskType               `protobuf:"varint,3,opt,name=type,proto3,enum=neurun.TaskType" json:"type,omitempty"`
	Status     TaskStatus             `protobuf:"varint,4,opt,name=status,proto3,enum=neurun.TaskStatus" json:"status,omitempty"`
	Retries    uint32                 `protobuf:"varint,5,opt,name=retries,proto3" json:"retries,omitempty"`
	RetryDelay *durationpb.Duration   `protobuf:"bytes,6,opt,name=retryDelay,proto3" json:"retryDelay,omitempty"`
	Condition  *string                `protobuf:"bytes,7,opt,name=condition,proto3,oneof" json:"condition,omitempty"`
	// Types that are valid to be assigned to Payload:
	//
	//	*Task_LogPayload
	//	*Task_HttpPayload
	Payload       isTask_Payload `protobuf_oneof:"payload"`
	Next          []*Task        `protobuf:"bytes,10,rep,name=next,proto3" json:"next,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Task) Reset() {
	*x = Task{}
	mi := &file_task_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Task) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Task) ProtoMessage() {}

func (x *Task) ProtoReflect() protoreflect.Message {
	mi := &file_task_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Task.ProtoReflect.Descriptor instead.
func (*Task) Descriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{1}
}

func (x *Task) GetId() string {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return ""
}

func (x *Task) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Task) GetType() TaskType {
	if x != nil {
		return x.Type
	}
	return TaskType_TASK_TYPE_UNSPECIFIED
}

func (x *Task) GetStatus() TaskStatus {
	if x != nil {
		return x.Status
	}
	return TaskStatus_TASK_STATUS_UNSPECIFIED
}

func (x *Task) GetRetries() uint32 {
	if x != nil {
		return x.Retries
	}
	return 0
}

func (x *Task) GetRetryDelay() *durationpb.Duration {
	if x != nil {
		return x.RetryDelay
	}
	return nil
}

func (x *Task) GetCondition() string {
	if x != nil && x.Condition != nil {
		return *x.Condition
	}
	return ""
}

func (x *Task) GetPayload() isTask_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Task) GetLogPayload() *LogPayload {
	if x != nil {
		if x, ok := x.Payload.(*Task_LogPayload); ok {
			return x.LogPayload
		}
	}
	return nil
}

func (x *Task) GetHttpPayload() *HTTPPayload {
	if x != nil {
		if x, ok := x.Payload.(*Task_HttpPayload); ok {
			return x.HttpPayload
		}
	}
	return nil
}

func (x *Task) GetNext() []*Task {
	if x != nil {
		return x.Next
	}
	return nil
}

type isTask_Payload interface {
	isTask_Payload()
}

type Task_LogPayload struct {
	LogPayload *LogPayload `protobuf:"bytes,8,opt,name=logPayload,proto3,oneof"`
}

type Task_HttpPayload struct {
	HttpPayload *HTTPPayload `protobuf:"bytes,9,opt,name=httpPayload,proto3,oneof"`
}

func (*Task_LogPayload) isTask_Payload() {}

func (*Task_HttpPayload) isTask_Payload() {}

type LogPayload struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Message       string                 `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogPayload) Reset() {
	*x = LogPayload{}
	mi := &file_task_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogPayload) ProtoMessage() {}

func (x *LogPayload) ProtoReflect() protoreflect.Message {
	mi := &file_task_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogPayload.ProtoReflect.Descriptor instead.
func (*LogPayload) Descriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{2}
}

func (x *LogPayload) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type HTTPPayload struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Url                string                 `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Method             string                 `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	Body               []byte                 `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
	Headers            map[string]string      `protobuf:"bytes,4,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	QueryParams        map[string]string      `protobuf:"bytes,5,rep,name=queryParams,proto3" json:"queryParams,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Timeout            *durationpb.Duration   `protobuf:"bytes,6,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Auth               *HTTPAuth              `protobuf:"bytes,7,opt,name=auth,proto3" json:"auth,omitempty"`
	FollowRedirects    bool                   `protobuf:"varint,8,opt,name=followRedirects,proto3" json:"followRedirects,omitempty"`
	VerifySSL          bool                   `protobuf:"varint,9,opt,name=verifySSL,proto3" json:"verifySSL,omitempty"`
	ExpectedStatusCode int32                  `protobuf:"varint,10,opt,name=expectedStatusCode,proto3" json:"expectedStatusCode,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *HTTPPayload) Reset() {
	*x = HTTPPayload{}
	mi := &file_task_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPPayload) ProtoMessage() {}

func (x *HTTPPayload) ProtoReflect() protoreflect.Message {
	mi := &file_task_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPPayload.ProtoReflect.Descriptor instead.
func (*HTTPPayload) Descriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{3}
}

func (x *HTTPPayload) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *HTTPPayload) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *HTTPPayload) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

func (x *HTTPPayload) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *HTTPPayload) GetQueryParams() map[string]string {
	if x != nil {
		return x.QueryParams
	}
	return nil
}

func (x *HTTPPayload) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

func (x *HTTPPayload) GetAuth() *HTTPAuth {
	if x != nil {
		return x.Auth
	}
	return nil
}

func (x *HTTPPayload) GetFollowRedirects() bool {
	if x != nil {
		return x.FollowRedirects
	}
	return false
}

func (x *HTTPPayload) GetVerifySSL() bool {
	if x != nil {
		return x.VerifySSL
	}
	return false
}

func (x *HTTPPayload) GetExpectedStatusCode() int32 {
	if x != nil {
		return x.ExpectedStatusCode
	}
	return 0
}

type HTTPAuth struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to AuthType:
	//
	//	*HTTPAuth_Basic
	//	*HTTPAuth_Bearer
	//	*HTTPAuth_ApiKey
	AuthType      isHTTPAuth_AuthType `protobuf_oneof:"auth_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPAuth) Reset() {
	*x = HTTPAuth{}
	mi := &file_task_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPAuth) ProtoMessage() {}

func (x *HTTPAuth) ProtoReflect() protoreflect.Message {
	mi := &file_task_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPAuth.ProtoReflect.Descriptor instead.
func (*HTTPAuth) Descriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{4}
}

func (x *HTTPAuth) GetAuthType() isHTTPAuth_AuthType {
	if x != nil {
		return x.AuthType
	}
	return nil
}

func (x *HTTPAuth) GetBasic() *HTTPBasicAuth {
	if x != nil {
		if x, ok := x.AuthType.(*HTTPAuth_Basic); ok {
			return x.Basic
		}
	}
	return nil
}

func (x *HTTPAuth) GetBearer() *HTTPBearerAuth {
	if x != nil {
		if x, ok := x.AuthType.(*HTTPAuth_Bearer); ok {
			return x.Bearer
		}
	}
	return nil
}

func (x *HTTPAuth) GetApiKey() *HTTPApiKeyAuth {
	if x != nil {
		if x, ok := x.AuthType.(*HTTPAuth_ApiKey); ok {
			return x.ApiKey
		}
	}
	return nil
}

type isHTTPAuth_AuthType interface {
	isHTTPAuth_AuthType()
}

type HTTPAuth_Basic struct {
	Basic *HTTPBasicAuth `protobuf:"bytes,1,opt,name=basic,proto3,oneof"`
}

type HTTPAuth_Bearer struct {
	Bearer *HTTPBearerAuth `protobuf:"bytes,2,opt,name=bearer,proto3,oneof"`
}

type HTTPAuth_ApiKey struct {
	ApiKey *HTTPApiKeyAuth `protobuf:"bytes,3,opt,name=apiKey,proto3,oneof"`
}

func (*HTTPAuth_Basic) isHTTPAuth_AuthType() {}

func (*HTTPAuth_Bearer) isHTTPAuth_AuthType() {}

func (*HTTPAuth_ApiKey) isHTTPAuth_AuthType() {}

type HTTPBasicAuth struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Username      string                 `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password      string                 `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPBasicAuth) Reset() {
	*x = HTTPBasicAuth{}
	mi := &file_task_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPBasicAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPBasicAuth) ProtoMessage() {}

func (x *HTTPBasicAuth) ProtoReflect() protoreflect.Message {
	mi := &file_task_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPBasicAuth.ProtoReflect.Descriptor instead.
func (*HTTPBasicAuth) Descriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{5}
}

func (x *HTTPBasicAuth) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *HTTPBasicAuth) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type HTTPBearerAuth struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Token         string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPBearerAuth) Reset() {
	*x = HTTPBearerAuth{}
	mi := &file_task_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPBearerAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPBearerAuth) ProtoMessage() {}

func (x *HTTPBearerAuth) ProtoReflect() protoreflect.Message {
	mi := &file_task_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPBearerAuth.ProtoReflect.Descriptor instead.
func (*HTTPBearerAuth) Descriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{6}
}

func (x *HTTPBearerAuth) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

type HTTPApiKeyAuth struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Location      HTTPApiKeyLocation     `protobuf:"varint,3,opt,name=location,proto3,enum=neurun.HTTPApiKeyLocation" json:"location,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HTTPApiKeyAuth) Reset() {
	*x = HTTPApiKeyAuth{}
	mi := &file_task_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPApiKeyAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPApiKeyAuth) ProtoMessage() {}

func (x *HTTPApiKeyAuth) ProtoReflect() protoreflect.Message {
	mi := &file_task_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPApiKeyAuth.ProtoReflect.Descriptor instead.
func (*HTTPApiKeyAuth) Descriptor() ([]byte, []int) {
	return file_task_proto_rawDescGZIP(), []int{7}
}

func (x *HTTPApiKeyAuth) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *HTTPApiKeyAuth) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *HTTPApiKeyAuth) GetLocation() HTTPApiKeyLocation {
	if x != nil {
		return x.Location
	}
	return HTTPApiKeyLocation_HTTP_API_KEY_LOCATION_UNSPECIFIED
}

var File_task_proto protoreflect.FileDescriptor

const file_task_proto_rawDesc = "" +
	"\n" +
	"\n" +
	"task.proto\x12\x06neurun\x1a\x1egoogle/protobuf/duration.proto\"\xfc\x02\n" +
	"\x11CreateTaskRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12$\n" +
	"\x04type\x18\x02 \x01(\x0e2\x10.neurun.TaskTypeR\x04type\x12\x18\n" +
	"\aretries\x18\x03 \x01(\rR\aretries\x129\n" +
	"\n" +
	"retryDelay\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"retryDelay\x12!\n" +
	"\tcondition\x18\x05 \x01(\tH\x01R\tcondition\x88\x01\x01\x124\n" +
	"\n" +
	"logPayload\x18\x06 \x01(\v2\x12.neurun.LogPayloadH\x00R\n" +
	"logPayload\x127\n" +
	"\vhttpPayload\x18\a \x01(\v2\x13.neurun.HTTPPayloadH\x00R\vhttpPayload\x12-\n" +
	"\x04next\x18\b \x03(\v2\x19.neurun.CreateTaskRequestR\x04nextB\t\n" +
	"\apayloadB\f\n" +
	"\n" +
	"_condition\"\xaa\x03\n" +
	"\x04Task\x12\x13\n" +
	"\x02id\x18\x01 \x01(\tH\x01R\x02id\x88\x01\x01\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12$\n" +
	"\x04type\x18\x03 \x01(\x0e2\x10.neurun.TaskTypeR\x04type\x12*\n" +
	"\x06status\x18\x04 \x01(\x0e2\x12.neurun.TaskStatusR\x06status\x12\x18\n" +
	"\aretries\x18\x05 \x01(\rR\aretries\x129\n" +
	"\n" +
	"retryDelay\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"retryDelay\x12!\n" +
	"\tcondition\x18\a \x01(\tH\x02R\tcondition\x88\x01\x01\x124\n" +
	"\n" +
	"logPayload\x18\b \x01(\v2\x12.neurun.LogPayloadH\x00R\n" +
	"logPayload\x127\n" +
	"\vhttpPayload\x18\t \x01(\v2\x13.neurun.HTTPPayloadH\x00R\vhttpPayload\x12 \n" +
	"\x04next\x18\n" +
	" \x03(\v2\f.neurun.TaskR\x04nextB\t\n" +
	"\apayloadB\x05\n" +
	"\x03_idB\f\n" +
	"\n" +
	"_condition\"&\n" +
	"\n" +
	"LogPayload\x12\x18\n" +
	"\amessage\x18\x01 \x01(\tR\amessage\"\x9e\x04\n" +
	"\vHTTPPayload\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x16\n" +
	"\x06method\x18\x02 \x01(\tR\x06method\x12\x12\n" +
	"\x04body\x18\x03 \x01(\fR\x04body\x12:\n" +
	"\aheaders\x18\x04 \x03(\v2 .neurun.HTTPPayload.HeadersEntryR\aheaders\x12F\n" +
	"\vqueryParams\x18\x05 \x03(\v2$.neurun.HTTPPayload.QueryParamsEntryR\vqueryParams\x123\n" +
	"\atimeout\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\atimeout\x12$\n" +
	"\x04auth\x18\a \x01(\v2\x10.neurun.HTTPAuthR\x04auth\x12(\n" +
	"\x0ffollowRedirects\x18\b \x01(\bR\x0ffollowRedirects\x12\x1c\n" +
	"\tverifySSL\x18\t \x01(\bR\tverifySSL\x12.\n" +
	"\x12expectedStatusCode\x18\n" +
	" \x01(\x05R\x12expectedStatusCode\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a>\n" +
	"\x10QueryParamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xaa\x01\n" +
	"\bHTTPAuth\x12-\n" +
	"\x05basic\x18\x01 \x01(\v2\x15.neurun.HTTPBasicAuthH\x00R\x05basic\x120\n" +
	"\x06bearer\x18\x02 \x01(\v2\x16.neurun.HTTPBearerAuthH\x00R\x06bearer\x120\n" +
	"\x06apiKey\x18\x03 \x01(\v2\x16.neurun.HTTPApiKeyAuthH\x00R\x06apiKeyB\v\n" +
	"\tauth_type\"G\n" +
	"\rHTTPBasicAuth\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x02 \x01(\tR\bpassword\"&\n" +
	"\x0eHTTPBearerAuth\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\"p\n" +
	"\x0eHTTPApiKeyAuth\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x126\n" +
	"\blocation\x18\x03 \x01(\x0e2\x1a.neurun.HTTPApiKeyLocationR\blocation*L\n" +
	"\bTaskType\x12\x19\n" +
	"\x15TASK_TYPE_UNSPECIFIED\x10\x00\x12\x11\n" +
	"\rTASK_TYPE_LOG\x10\x01\x12\x12\n" +
	"\x0eTASK_TYPE_HTTP\x10\x02*\x8e\x01\n" +
	"\n" +
	"TaskStatus\x12\x1b\n" +
	"\x17TASK_STATUS_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13TASK_STATUS_PENDING\x10\x01\x12\x17\n" +
	"\x13TASK_STATUS_RUNNING\x10\x02\x12\x19\n" +
	"\x15TASK_STATUS_COMPLETED\x10\x03\x12\x16\n" +
	"\x12TASK_STATUS_FAILED\x10\x04*~\n" +
	"\x12HTTPApiKeyLocation\x12%\n" +
	"!HTTP_API_KEY_LOCATION_UNSPECIFIED\x10\x00\x12 \n" +
	"\x1cHTTP_API_KEY_LOCATION_HEADER\x10\x01\x12\x1f\n" +
	"\x1bHTTP_API_KEY_LOCATION_QUERY\x10\x02B4Z2github.com/luis12loureiro/neurun/apps/workflow/genb\x06proto3"

var (
	file_task_proto_rawDescOnce sync.Once
	file_task_proto_rawDescData []byte
)

func file_task_proto_rawDescGZIP() []byte {
	file_task_proto_rawDescOnce.Do(func() {
		file_task_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_task_proto_rawDesc), len(file_task_proto_rawDesc)))
	})
	return file_task_proto_rawDescData
}

var file_task_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_task_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_task_proto_goTypes = []any{
	(TaskType)(0),               // 0: neurun.TaskType
	(TaskStatus)(0),             // 1: neurun.TaskStatus
	(HTTPApiKeyLocation)(0),     // 2: neurun.HTTPApiKeyLocation
	(*CreateTaskRequest)(nil),   // 3: neurun.CreateTaskRequest
	(*Task)(nil),                // 4: neurun.Task
	(*LogPayload)(nil),          // 5: neurun.LogPayload
	(*HTTPPayload)(nil),         // 6: neurun.HTTPPayload
	(*HTTPAuth)(nil),            // 7: neurun.HTTPAuth
	(*HTTPBasicAuth)(nil),       // 8: neurun.HTTPBasicAuth
	(*HTTPBearerAuth)(nil),      // 9: neurun.HTTPBearerAuth
	(*HTTPApiKeyAuth)(nil),      // 10: neurun.HTTPApiKeyAuth
	nil,                         // 11: neurun.HTTPPayload.HeadersEntry
	nil,                         // 12: neurun.HTTPPayload.QueryParamsEntry
	(*durationpb.Duration)(nil), // 13: google.protobuf.Duration
}
var file_task_proto_depIdxs = []int32{
	0,  // 0: neurun.CreateTaskRequest.type:type_name -> neurun.TaskType
	13, // 1: neurun.CreateTaskRequest.retryDelay:type_name -> google.protobuf.Duration
	5,  // 2: neurun.CreateTaskRequest.logPayload:type_name -> neurun.LogPayload
	6,  // 3: neurun.CreateTaskRequest.httpPayload:type_name -> neurun.HTTPPayload
	3,  // 4: neurun.CreateTaskRequest.next:type_name -> neurun.CreateTaskRequest
	0,  // 5: neurun.Task.type:type_name -> neurun.TaskType
	1,  // 6: neurun.Task.status:type_name -> neurun.TaskStatus
	13, // 7: neurun.Task.retryDelay:type_name -> google.protobuf.Duration
	5,  // 8: neurun.Task.logPayload:type_name -> neurun.LogPayload
	6,  // 9: neurun.Task.httpPayload:type_name -> neurun.HTTPPayload
	4,  // 10: neurun.Task.next:type_name -> neurun.Task
	11, // 11: neurun.HTTPPayload.headers:type_name -> neurun.HTTPPayload.HeadersEntry
	12, // 12: neurun.HTTPPayload.queryParams:type_name -> neurun.HTTPPayload.QueryParamsEntry
	13, // 13: neurun.HTTPPayload.timeout:type_name -> google.protobuf.Duration
	7,  // 14: neurun.HTTPPayload.auth:type_name -> neurun.HTTPAuth
	8,  // 15: neurun.HTTPAuth.basic:type_name -> neurun.HTTPBasicAuth
	9,  // 16: neurun.HTTPAuth.bearer:type_name -> neurun.HTTPBearerAuth
	10, // 17: neurun.HTTPAuth.apiKey:type_name -> neurun.HTTPApiKeyAuth
	2,  // 18: neurun.HTTPApiKeyAuth.location:type_name -> neurun.HTTPApiKeyLocation
	19, // [19:19] is the sub-list for method output_type
	19, // [19:19] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_task_proto_init() }
func file_task_proto_init() {
	if File_task_proto != nil {
		return
	}
	file_task_proto_msgTypes[0].OneofWrappers = []any{
		(*CreateTaskRequest_LogPayload)(nil),
		(*CreateTaskRequest_HttpPayload)(nil),
	}
	file_task_proto_msgTypes[1].OneofWrappers = []any{
		(*Task_LogPayload)(nil),
		(*Task_HttpPayload)(nil),
	}
	file_task_proto_msgTypes[4].OneofWrappers = []any{
		(*HTTPAuth_Basic)(nil),
		(*HTTPAuth_Bearer)(nil),
		(*HTTPAuth_ApiKey)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_task_proto_rawDesc), len(file_task_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_task_proto_goTypes,
		DependencyIndexes: file_task_proto_depIdxs,
		EnumInfos:         file_task_proto_enumTypes,
		MessageInfos:      file_task_proto_msgTypes,
	}.Build()
	File_task_proto = out.File
	file_task_proto_goTypes = nil
	file_task_proto_depIdxs = nil
}
